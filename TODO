 - implement port infra
 - memory mapped infra
 - prism BIOS
    - set internal interrupts
    - main app writes indexes of storages in main mem, BIOS reads them
    - set correct modes to peripheral
    - find bootable media
    - start bootloader
    - initial CPU test
    - test timers/video/keyboard
 - peripheral
    - PIC
    - PIT
    - video
    - keyboard
    - flopy
    - HDD

-------------------------------------------------------

PIC

 - IRR - input interrupts which are active
 - ISR - serviced interrupts
 - IMR - masked interrupts

 ICW1
  - LTIM (Level trigger mode)
    - 1 - Level
    - 0 - Edge
  - ADI (Call address interval)
    - 1 - 4
    - 0 - 8
  - SNGL
    - 1 - single
    - 0 - cascade
  - IC4
    - 1 - ICW4 needed
    - 0 - no ICW4 needed

 ICW2 (interrupt address)
  - bits 3-7 -> T3-T7

 ICW3 (cascade config)
  - S0-S7 - 1 has slave (master)
  - ID0-ID2 - id (slave)

 ICW4
  - SFNM (speciall fully nested mode)
    - 1 - yes
  - BUF
    - 1 - yes
  - M/S (works only in BUF mode)
    - 1 - master
    - 0 - slave
  - AEOI (automatic end of interrupt)
    - 1 - yes
  - uPM (microprocessor mode)
    - 0 - 80/85
    - 1 - 8086

 OCW1 (configure IMR)
  - 1 - mask (disable interrupt)
  - 0 - unmask (enable interrupt)

 OCW2
  - R (rotate)
    - 1 - yes
  - SL (specific)
    - 1 - yes
  - EOI (end of interrupt)
    - 1 - EOI
    - 0 - AEOI
  - L (interrupt level)
    - 3 bits

 OCW3
  - RIS
  - RR
    - 11 - Read IS
    - 01 - Read IR
  - P (poll)
    - 1 - poll command
  - SMM
  - ESMM
    - 11 - set special mask
    - 01 - reset special mask

data PicCommand = PicSetIMR
               | PicOp Rotate EOI Maybe(Level)
               | PicReadIS
               | PicReadIR

newtype PicICW = PicICW Int

picICW1 = PicICW 1
picICW2 = PicICW 2
picICW3 = PicICW 3
picICW4 = PicICW 4
picICWDone = PicICW 5

data PicConfig = PicConfig {
    picConfigLevel :: Bool,
    picConfigSingle :: Bool,
    picConfigADI :: Uint8,
    picConfigAddr :: Uint8,
    --picConfigSlaveMask :: Uint8, -- use slave array
    --picConfigSlaveId :: Uint8,
    picConfigNested :: Bool,
    picConfigBuf :: Bool,
    --picConfigMode :: Master/Slave,
    picConfigAEOI :: Bool,
    picICW4Enabled :: Bool,
    picConfigUPM :: 8086
}

data PicState = PicState {
    picStateIMR :: Uint8,
    picStateIRR :: Uint8,
    picStateISR :: Uint8,
    picStateSMask :: Bool,
    picStateLowestPrio :: Uint8,
    picInitStage :: PicICW
}

data Pic = Pic {
    picConfig :: PicConfig,
    picState :: PicState
}

data PicPC = PicPC {
    picPCMaster :: Pic,
    picPCSlave :: Pic
}

processPicWrite :: Pic -> (Pic, Bool)
processPicRead :: Pic -> (Pic, Uint8)

Q
 - how to send interrupt request to CPU?
    - It might take some time for CPU to start processing interrupt,
      higher priority IRQ might raise
    - What to do if interrupt goes away while CPU is doing something?
      - When interrupt goes before CPU ack then IRQ 7 is generated
        and returned to CPU. So, CPU always get a response.
        It is possible to distinct real IRQ 7 and this placeholder
        in real IRQ 7 there will be IRR bit high
      - Bochs just clears IRR bit and when CPU does ack IRQ 7 is returned
    - In case of queue it might take some time for CPU to process it,
      as the result another interrupt might occur (higher priority)
      How to notifiy CPU about it?
      Is it necessary to notify at all?
    - Real 8259 uses handshake mechansim for it
      it waits for CPU to ack interrupt to times and only after last
      ack it send interrupt number. If interrupt number was changed
      8259 will send different number after second ack
      -- PIC will be implemented in context of CPU, there will be
         special function for ack
    - Solution is to implement PIC/PIT in context of CPU itself
      this way we solve all problems: reading current value of PIT`s
      counter, AOI race and short counter of PIT
      In this case we need to implement local peripheral infra, it will
      handle PIT and PIC. There will be no PIC/PIT in remote infra.
      But Peripheral and PeripheralDevices should be different for
      local and remote infras. And handlers have to be different too
      -- TODO

-------------------------------------------------------

data Peripheral = Peripheral {
        peripheralPortRegion :: PortIORegion,
        peripheralMemRegion :: MemIORegion,
        peripheralPort :: Array.Array IOHandlerIndex PeripheralHandlerPort,
        peripheralMem :: Array.Array IOHandlerIndex PeripheralHandlerMem,
        peripheralDevices :: PeripheralDevices
    }

data PeripheralLocal = PeripheralLocal {
        peripheralPort :: Array.Array IOHandlerIndex PeripheralHandlerPort,
        peripheralMem :: Array.Array IOHandlerIndex PeripheralHandlerMem,
        peripheralDevices :: PeripheralDevices
    }


 - first task is to generalize IOCtx (+)
   - can split IOCtx
     - upper part will be two arrays which will containt specific data
     - lower part will be existential and will contain queue + local peripherals
 - local operations in context of CPU (+)
   - IOCtx lower part will have IORef on local peripherals
   - this way we can work with memory and peripherals
 - separation of local and remote IO handlers (+)
   - handlers can be parameterized
   - local/remote peripherals structure will be a parameter
   - specific implementations will be written for each peripheral type
 - remote peripherals implementation, should be generalized too (+)
   - remote peripherals structure can be parameterized with specific container
   - container will have specific structure inside
   - unlike CPU we can pass parameter along with Peripherals context
 -----
 - IOCtx lower will be used to process incomming interrupts ("dispatch")
   - there will be explicit knowledge about PIC inside of IOCtx lower
 - AOI
   - aoi will be part of IOCtxLocals interface
   - it will be called from processInterrupts function before processing int
 - interrupt input
   - interrupts will be sent to CPU via command queue
   - they will be handled by dispatch function of IOCtxLocals interface

data PCPlatformLocal = PCPlatformLocal {
        pcPic :: Pic,
        pcPit :: Pit,
        pcCycles :: Int,
    }

dispatchInterruptUp :: PCPlatformLocal -> PrismInt -> IO (PCPlatformLocal, Bool)
dispatchInterruptUp pc int = do
    res <- picInterruptRaise (pcPic pc) int
    ...

ackInterrupt :: PCPlatformLocal -> IO (PCPlatformLocal, PrismInt)
ackInterrupt pc = do
    picAck (pcPic pc)
    ...

runPeripherals :: Ctx -> PCPlatformLocal -> IO (Ctx, PCPlatformLocal)
runPeripherals ctx pc = do
    picRun (pcPic pc)
    ...

-------------------------------------------------------

data PicConfigStep = PicConfigICW1
                     | ...
                     | PicConfigOCW1
                     | ...

data Pic8259A = Pic8259A {
        picIRR :: Uint8, -- Interrupt Request Register
        picISR :: Uint8, -- In-Service Register
        picIMR :: Uint8, -- Interrupt Mask Register
        picInitStep -- ICW step (1-4)
        picControlStep - OCW step (1-4)
        --picConfigStep
    }

--data Pic = Pic {
    --}

-------------------------------------------------------

newtype PitMode = PitMode Uint8

MVar or IORef

data PitCounter = PitCounter {
        pitMode :: PitMode,
        pitCounter :: MVar Word64,
        pitTimeout :: Int, -- timeout in us
        pitScale :: Uint16, -- mapping between system time and counter
        pitPreset :: Uint16, -- value which is loaded into counter
        pitThreadId :: Maybe ThreadId
    }

data PIT = PIT {
        pitCounters :: [PitCounter]
    }

data PeripheralDevices = PeripheralDevices {
        peripheralPIT :: PIT,
    }

-------------------------------------------------------
