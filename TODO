 - prism BIOS
    - set internal interrupts
    - main app writes indexes of storages in main mem, BIOS reads them
    - set correct modes to peripheral
    - find bootable media
    - start bootloader
    - initial CPU test
    - test timers/video/keyboard
 - peripheral
    - PPI (8255A)
    - keyboard (XT style)
    - video
    - DMA (intel 8237)
    - flopy
    - HDD
    - CMOS
 - later
    - keyboard (8042)

-------------------------------------------------------

HSBIOS
 - Simple implementation of PC BIOS
 - Completely in haskell
 - Will not use "real" peripherals

Memory addresses
 - 0 - 0x3ff - interrupt vectors
 - 0x400 - 0x500 - BIOS DATA
 - 0x7C00 - Boot sector (start for user code)
 - 0xE0000 - 0xFFFFF - BIOS ROM
 - 0xFFFF0 - 8086 start instruction

BIOS RAM area
 - 0x0-0x7 - 4 serial ports
 - 0x8-0xf - 4 parallel ports
 - 0x10-0x11 - installed devices (int 0x11)
 - 0x12 - POST
 - 0x13-0x14 - installed memory in KB
 - 0x15-0x16 - POST
 - 0x17 - keyboard shift flags
 - 0x18 - keyboard ext shift flags
 - 0x19 - alt key + numeric keypad
 - 0x1A-0x1B - pointer to next char in keyboard buffer
 - 0x1C-0x1D - pointer to first spot in keyboard buffer
 - 0x1E - 16w keyboard buffer
 - 0x3E - diskette recalibrate status
 - 0x3F - diskette motor status
 - 0x40 - diskette motor timeout
 - 0x41 - diskette return code
 - 0x42-0x48 - diskette controller status
 - 0x49 - video mode setting
 - 0x4A - number of columns on screen
 - 0x4C - current page size (video)
 - 0x4E - current page address (video)
 - 0x50 - cursor pos on each page (8 pages)
 - 0x60 - cursor type
 - 0x62 - current page number (video)
 - 0x63 - io port video
 - 0x65 - current mode selector reg
 - 0x66 - current palette value
 - 0x67-0x6A - POST
 - 0x6B - POST
 - 0x6C - timer count
 - 0x70 - 24h rollover flag
 - 0x71 - ctrl-break flag
 - 0x72 - POST
 - 0x74 - status from last hdd operation
 - 0x75 - number of hdds
 - 0x76 - hdd control byte
 - 0x77 - hdd port offset
 - 0x78 - printer timeout table
 - 0x7C - serial timeout table
 - 0x80 - offset to start of keyboard buffer(from seg 0x40)
 - 0x82 - offset to end of keyboard buffer
 - 0x84 - number of rows on screen
 - 0x85 - char height (VGA)
 - 0x87 - VGA
 - 0x88 - VGA
 - 0x89 - VGA
 - 0x8A - VGA
 - 0x8B - diskette rate
 - 0x8C - hdd status
 - 0x8D - hdd error
 - 0x8E - hdd interrupt flag
 - 0x8F - diskette controller info
 - 0x90-0x91 - media type of both drives
 - 0x92 - diskette driver service area
 - 0x94 - current track number
 - 0x96 - keyboard status byte
 - 0x97 - keyboard LED status
 - 0x98 - user wait flag offset address
 - 0x9A - user wait flag segment address
 - 0x9C - LSB of wait count
 - 0x9E - MSB of wait count
 - 0xA0 - wait active flag
 - 0xA8 - VGA
 - 0xB0-0xB5 - reserved
 - 0xB6-0xB8 - POST
 - 0xC0-0xCD - reserved
 - 0xCE - count of days since 1980
 - 0xCF-0xFF - reserved
 - 0x100 - print screen status bytes

CHS
 A = (c * N_heads + h) * N_sectors + (s - 1)

CMOS for diskette
0x10 bits 7-4 drive 0 type (0x4 - 1.44)
     bits 3-0 drive 1 type (0x4 - 1.44)

Diskette parameters table 0x1E
 0x00 - bits 7-4 drive type/transfer rate -> 0xd0
        bits 3-0 head unload time -> 0x0f
 0x01 - bits 7-1 head load time -> 0x02
        bit 0 non-DMA flag -> 0x00
 0x02 - motor turn-off delay -> 0x25
 0x03 - bytes per sector -> 0x02 (512)
 0x04 - sectors per track -> 0x18 (18)
 0x05 - gap length -> 0x1B
 0x06 - data length -> 0xff
 0x07 - gap length for format -> 0x6c
 0x08 - fill byte for format -> 0xF6
 0x09 - head settle time -> 0x0F
 0x0A - motor start time -> 0x08

HDD parameters table 0x41(0x46 for driver 1)
 0x00 - number of cylinders (2 bytes)
 0x02 - number of heads
 0x03 - reserved (2 bytes) -> 0
 0x05 - starting write precompensation cylinder (2 bytes) -> 0
 0x07 - reserved -> 0
 0x08 - control byte -> 0xC0
 0x09 - reserved (3 bytes) -> 0
 0x0C - landing zone cylinder (2 bytes) -> 0
 0x0E - number of sectors per track
 0x0F - reserved -> 0

Functions
 - int 8 (Timer) - BIOS internal (ISR)
 - int 9 (Keyboard) - BIOS internal (ISR)
 - int 0x10 (Video)
   - ah 0 (Set video mode)
       - al 0-7, d-13
       - out al
        0x20 when mode > 7
        0x30 when mode 0-5 or 7
        0x3f when mode 6
   - ah 1 (Set cursor shape)
       - ch - bit 5 disable cursor, 4-0 top scan line
       - cl - bit 6-5 show cursor, 4-0 low scan line
   - ah 2 (Set cursor pos)
       - bh - display page number
       - dh - row
       - dl - column
       - out al = 0
   - ah 3 (Get cursor pos)
       - bh page number
       - out ax = 0
       - ch starting cursor scan line
       - cl ending cursor scan line
       - dh row number
       - dl column number
   - ah 6 (Scroll up)
       - al scroll distance in rows
       - bh attr for blank lines
       - ch top row scroll window
       - cl left column scroll window
       - dh bottom row scroll window
       - dl right column scroll window
   - ah 7 (Scroll down)
   - ah 8 (Get char)
       - bh page
       - out ah attr
       - al char
   - ah 9 (Write char + attr)
       - al ascii char
       - bh page
       - bl attr
       - cx repeat count
   - ah e (Write char)
       - al ascii char
       - bl color fg
       - bh page
   - ah f (Get video mode)
       - out ah number of columns
       - al mode
       - bh active page
 - int 0x11 (Get equipment)
   - Output to AX
       - Bits 15 - 14 - number of printers
       - Bits 13 - 12 - reserved
       - Bits 11 - 9  - number of serial ports
       - Bits 8 - reserved
       - Bits 7 - 6 - number diskettes
           - 00 - 1 diskette
           - 01 - 2 diskettes
       - Bits 5 - 4 - video mode
           - 00 - VGA/EGA/PGA
           - 01 - 40x25 color
           - 10 - 80x25 color
           - 11 - 80x25 mono
       - Bit 3 - reserved
       - Bit 2 - pointing device
       - Bit 1 - math coprocessor
       - Bit 0 - diskette for boot
 - int 0x12 (Get memory size)
   - Output to AX
 - int 0x13 (Disk)
   - ah 0 (Reset disk) -
   - ah 1 (Read status) -
   - ah 2 (Read sectors)
       - al - number of sectors
       - ch - track number
       - cl - sector number
       - dh - head number
       - dl - driver number (0x80 for hdd)
       - es:bx - pointer to buffer
       - out al - sectors read
   - ah 3 (Write sectors)
       - same as read
   - ah 4 (Verify sectors)
   - ah 5 (Format track)
   - ah 8 (Read params)
       - dl - drive number
       - out for diskette
        - ax - 0 -- always 0
        - bh - 0 -- always 0
        - bl - 04 (3.5", 1.44 MB)
        - ch - tracks
        - cl - sectors
        - dh - heads, always 1 when CMOS valid
        - dl - number of diskette drives
        - es:di - pointer to param table
        - CF = 0 when no error
       - out for HDD
        - ah - 0 when valid
               7 when drive number is invalid
        - al - always 0
        - ch - cylinder lower 8 bits, zero-based, 00 when ah == 7
        - cl - bits 0-5 sectors
               bits 6-7 cylinder high 2 bits (00 when ah == 7)
        - dh - heads
        - dl - number of drives, zero-base, 00 when ah == 7
        - es:di - pointer to param table
        - CF = 0 when no error
   - ah c (Seek)
   - ah 10 (Check ready)
   - ah 15 (Read type)
       - dl - driver number
       - out
        for HDD
        - ah - 03 fixed disk
        - cx - high bits of sectors number per-disk
        - dx - low bits of sectors number per-disk
   - ah 16 (Detect media change)
 - int 0x14 (Serial)
 - int 0x15 (System services)
 - int 0x16 (Keyboard) (DSR)
   - ah 0 (Get key)
     - Return 2 byte key in AX
        - AH contains Scan code
        - AL contains ASCII code
     - Remove key from buffer
     - When buffer is empty - suspend
   - ah 1 (Return keyboard status)
     - Return 2 byte key in AX
     - Key is not removed from buffer
     - If buffer is empty ZF=1
     - If buffer is not empty ZF=0
   - ah 2 (Return shift flag status)
     - AL contains flags
        - Bit 7 - Insert
        - Bit 6 - Caps Lock
        - Bit 5 - Num Lock
        - Bit 4 - Scroll Lock
        - Bit 3 - Alt pressed
        - Bit 2 - Ctrl pressed
        - Bit 1 - Left Shift pressed
        - Bit 0 - Right Shift pressed
   - ah 0x12 (Return extended shift flag status)
        - AL contains same flags as AH 2
        - AH contains flags
            - Bit 7 - SysReq pressed
            - Bit 6 - Caps Lock
            - Bit 5 - Num Lock
            - Bit 4 - Scroll Lock
            - Bit 3 - Right Alt
            - Bit 2 - Right Ctrl
            - Bit 1 - Left Alt
            - Bit 0 - Left Ctrl
 - int 0x17 (Printer)
 - int 0x19 (Reboot)
   - Loads 512 bytes from storage to 0x7C00 and transferres control
 - int 0x1a (Clock)
   - ah 0 (Read System Timer Time Counter)
     Ticks are 18.2 Hz
        - al - Timer overflow (0 when < 24h since boot)
        - CF (1 - error)
        - CX - High word ticks
        - DX - Low word ticks
   - ah 2 (Read Real Time Clock Time)
        - AL - Hours BCD
        - CF - 0 = clock operating
        - CH - Hours BCD
        - CL - Minutes BCD
        - DH - Seconds BCD
        - DL - Daylight saving time
   - ah 4 (Read Real Time Clock Date)
        - CF - 1 = update in progress
        - CH - Century in BCD (19 or 20)
        - CL - Year in BCD
        - DH - Month in BCD
        - DL - Day in BCD
 - int 0x1b (Break code)
 - int 0x1d (Video params)
 - int 0x1e (Disk params)

Communication types:
 - Peripheral -> CPU
    - Keyboard
        - Generates interrupts
        - Sends key make-break
        - Sends key code
    - Serial
    - Printer
 - CPU -> Peripheral
    - Video
        - Set/Get cursor
        - Set/Get video mode
        - Write/Get char
    - Disk
    - Serial
    - Printer
 - CPU -> CPU
    - Timer
    - Clock
    - Reboot
 - Static return
    - Memory size
    - Equipment
    - Video params
    - Disk params

Keyboard implementation
 - Set interrupt for keyboard IRQs
 - Make thread-safe keyboard state
 - Share state between CPU and peripheral thread
 - Upon receiving interrupt read keyboard shared state
 - Generate internal interrupts

Keyboard
 - Shift/Toggle keys: Shift, Alt, Ctrl, Caps Lock, Num Lock, Scroll Lock
 - Each "key" consists of two bytes: main and aux
 - Some keys have special function:
    - Ctrl-Alt-Del - System reset
    - Ctrl-Break - Break
    - Ctrl-NumLock - Pause
    - Shift-PrintScreen - Print screen
    - SysReq - System request

Video implementation
 - Spawn peripheral thread
 - Create shared video state
 - Each 30ms draw video frame
 - Check shared state before drawing
 - Shared state will have info about video updates (if video memory was updated since last screen draw)
 - CPU will update shared state when it touches video memory

Disk implementation
 - Read/Write file in CPU context
 - Hardcode default disk parameters
 - Use raw disk image of a default size

Timer implementation
 - Use CPU scheduler or PIT to create timer
 - Call BIOS function for each timer event
 - From BIOS call corresponding user interrupt

Clock implementation
 - Use base lib to read and convert current date
 - Ticks could be read from run-time

Static parameters
 - Will be hardcoded or defined via arguments

HW ports
 - Need PIC/PIT
 - Video cursor
 - Video resolution
 - Video scancode/refresh

TODO:
 - Implement BIOS structs +
 - Create keyboard infra +
 - Implement basic keyboard functions
    - Internal interrupt +
    - Char conversion
    - 0, 1, 2, 12 +
 - Implement BIOS tests (part of test-asm) +
    - Send keyboard interrupts + update shared state +
 - Implement BIOS timer +
 - Static parameters +
    - Hardcode default +
    - Create unit tests +
 - Implement basic video functions +
 - Implement simple application which uses BIOS +
    - Key echo (read key, write key) +
 - Implement BIOS disk/floppy
 - Implement bootloader logic in BIOS

-------------------------------------------------------

BIOS

data Key = Key {
}

data BiosKeyboard = BiosKeyboard {
    remoteKeyboardState :: SharedKeyboardState,
    keyList :: [Key],
}

data BiosState = BiosState {
    biosKeyboard :: BiosKeyboard,
}

class DirectCommandPeripheral m where
    directCommand :: DirectCommand -> m ()

-------------------------------------------------------

PIC

 - IRR - input interrupts which are active
 - ISR - serviced interrupts
 - IMR - masked interrupts

 ICW1
  - LTIM (Level trigger mode)
    - 1 - Level
    - 0 - Edge
  - ADI (Call address interval)
    - 1 - 4
    - 0 - 8
  - SNGL
    - 1 - single
    - 0 - cascade
  - IC4
    - 1 - ICW4 needed
    - 0 - no ICW4 needed

 ICW2 (interrupt address)
  - bits 3-7 -> T3-T7

 ICW3 (cascade config)
  - S0-S7 - 1 has slave (master)
  - ID0-ID2 - id (slave)

 ICW4
  - SFNM (speciall fully nested mode)
    - 1 - yes
  - BUF
    - 1 - yes
  - M/S (works only in BUF mode)
    - 1 - master
    - 0 - slave
  - AEOI (automatic end of interrupt)
    - 1 - yes
  - uPM (microprocessor mode)
    - 0 - 80/85
    - 1 - 8086

 OCW1 (configure IMR)
  - 1 - mask (disable interrupt)
  - 0 - unmask (enable interrupt)

 OCW2
  - R (rotate)
    - 1 - yes
  - SL (specific)
    - 1 - yes
  - EOI (end of interrupt)
    - 1 - EOI
    - 0 - AEOI
  - L (interrupt level)
    - 3 bits

 OCW3
  - RIS
  - RR
    - 11 - Read IS
    - 01 - Read IR
  - P (poll)
    - 1 - poll command
  - SMM
  - ESMM
    - 11 - set special mask
    - 01 - reset special mask

-------------------------------------------------------

actions
 - config
    - can trigger interrupt and scheduling actions
 - raise/lower interrupt
    - out pin status will be used to set PIC
 - schedule update
    - may trigger rescheduling
    - may trigger interrupt
 - write status/counter
    - may cause interrupts or scheduling
 - read status/counter
    - read does not cause actions
 - set gate
    - can trigger interrupt and scheduling

 - all actions require actual CPU cycles
 - CPU cycles always increment
 - CPU cycles never goes backwards

read-write
 - totally independent state and buffers for read (OL) and write (CR)
 - for multi bytes write it must be accumulated before set to CE

read commands
 - direct read from latches, latches follow CE
    - counter will be read directly according RW mode configured with controll command
    - second latch may go increment while first one is read
 - latch counter and then read latches
 - read back command

latch (OL) is held until
 - it is read
 - counter is reprogrammed
    - writing new counter values does not cause clear of OL
    - only control word applied to counter causes it
 latch is per-counter
 second latch command is ignored, first is held until it is read

read-back generates special output
 - 
 can latch multiple counters, same action as latch command
 when status and count latched, then first read value is status

counter components:
 - preset (Uint16), value written to counter (CR)
 - CR state
    - null count
 - CPU cycles when counting started
    - will be used when counter is read to emulate pulses
 - latch for status
 - read state
    - read latch (OL)
 - write state
    - write latch (CR)
 - mode (0-5)
 - count format (BIN/BCD)
 - out pin (1/0)

0x40 - timer 0
0x41 - timer 1
0x42 - timer 2
0x43 - code word
    - only write
    - no read
0x61 - speaker (out pin?)

-------------------------------------------------------
