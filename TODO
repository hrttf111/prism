 - implement interrupt infra
 - implement port infra
 - implement generalized mem/reg instructions
 - implement string operations and prefixes
 - debugging
    - gdb remote protocol?

-------------------------------------------------------
Interrupts

newtype PrismInt = PrismInt Uint8

data PrismInterrupt = PrismInterrupt {
        interruptsActive :: [PrismInt]
    }

activateInterrupt :: PrismInterrupt -> PrismInt -> PrismInterrupt
getActiveInterrupt :: PrismInterrupt -> (PrismInterrupt, PrismInt)
readInterruptAddress :: MonadIO m => Ctx -> PrismInt -> m Uint32

isInterruptActive :: PrismInterrupt -> Bool

processInterrupts :: MonadIO m => ... -> Ctx -> m Ctx
processInterrupts processInterruptInternal ctx = do
    let (interrupts, activeInt) = getActiveInterrupt $ ctxInterrupts ctx
    --todo: process flags
    address <- readInterruptAddress ctx activeInt
    case address of
        0x00000000 -> processInterruptInternal (ctx{ctxInterrupts = interrupts}) activeInt
        _ -> processInterruptCpu (ctx{ctxInterrupts = interrupts}) address

processInterruptCpu :: MonadIO m => Ctx -> Uint32 -> m Ctx
processInterruptCpu ctx address = do
    pushFlags ctx
    push =<< getIp ctx
    jmp ctx address

processInterruptInternal :: MonadIO m => InterrupArray -> Ctx -> PrismInt -> m Ctx
processInterruptInternal arr ctx (PrismInt int) = do
    func <- arr ! int
    func ctx int

---


-------------------------------------------------------
Ports

readPort16 :: MonadIO m => PortHandlers -> Uint16 -> m Uint16
readPort16 handlers port = 
    func <- handlers ! port
    func port
