 - prism BIOS
    - set internal interrupts
    - main app writes indexes of storages in main mem, BIOS reads them
    - set correct modes to peripheral
    - find bootable media
    - start bootloader
    - initial CPU test
    - test timers/video/keyboard
 - peripheral
    - PIT
    - CMOS
    - keyboard
    - video
    - flopy
    - HDD

-------------------------------------------------------

PIC

 - IRR - input interrupts which are active
 - ISR - serviced interrupts
 - IMR - masked interrupts

 ICW1
  - LTIM (Level trigger mode)
    - 1 - Level
    - 0 - Edge
  - ADI (Call address interval)
    - 1 - 4
    - 0 - 8
  - SNGL
    - 1 - single
    - 0 - cascade
  - IC4
    - 1 - ICW4 needed
    - 0 - no ICW4 needed

 ICW2 (interrupt address)
  - bits 3-7 -> T3-T7

 ICW3 (cascade config)
  - S0-S7 - 1 has slave (master)
  - ID0-ID2 - id (slave)

 ICW4
  - SFNM (speciall fully nested mode)
    - 1 - yes
  - BUF
    - 1 - yes
  - M/S (works only in BUF mode)
    - 1 - master
    - 0 - slave
  - AEOI (automatic end of interrupt)
    - 1 - yes
  - uPM (microprocessor mode)
    - 0 - 80/85
    - 1 - 8086

 OCW1 (configure IMR)
  - 1 - mask (disable interrupt)
  - 0 - unmask (enable interrupt)

 OCW2
  - R (rotate)
    - 1 - yes
  - SL (specific)
    - 1 - yes
  - EOI (end of interrupt)
    - 1 - EOI
    - 0 - AEOI
  - L (interrupt level)
    - 3 bits

 OCW3
  - RIS
  - RR
    - 11 - Read IS
    - 01 - Read IR
  - P (poll)
    - 1 - poll command
  - SMM
  - ESMM
    - 11 - set special mask
    - 01 - reset special mask

-------------------------------------------------------

actions
 - config
    - can trigger interrupt and scheduling actions
 - raise/lower interrupt
    - out pin status will be used to set PIC
 - schedule update
    - may trigger rescheduling
    - may trigger interrupt
 - write status/counter
    - may cause interrupts or scheduling
 - read status/counter
    - read does not cause actions
 - set gate
    - can trigger interrupt and scheduling

 - all actions require actual CPU cycles
 - CPU cycles always increment
 - CPU cycles never goes backwards

read-write
 - totally independent state and buffers for read (OL) and write (CR)
 - for multi bytes write it must be accumulated before set to CE

read commands
 - direct read from latches, latches follow CE
    - counter will be read directly according RW mode configured with controll command
    - second latch may go increment while first one is read
 - latch counter and then read latches
 - read back command

latch (OL) is held until
 - it is read
 - counter is reprogrammed
    - writing new counter values does not cause clear of OL
    - only control word applied to counter causes it
 latch is per-counter
 second latch command is ignored, first is held until it is read

read-back generates special output
 - 
 can latch multiple counters, same action as latch command
 when status and count latched, then first read value is status

counter components:
 - preset (Uint16), value written to counter (CR)
 - CR state
    - null count
 - CPU cycles when counting started
    - will be used when counter is read to emulate pulses
 - latch for status
 - read state
    - read latch (OL)
 - write state
    - write latch (CR)
 - mode (0-5)
 - count format (BIN/BCD)
 - out pin (1/0)

0x40 - timer 0
0x41 - timer 1
0x42 - timer 2
0x43 - code word
    - only write
    - no read
0x61 - speaker (out pin?)

TODO:
 - implement all modes
 - BCD counting
 - minor fixes

-------------------------------------------------------
