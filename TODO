 - prism BIOS
    - set internal interrupts
    - main app writes indexes of storages in main mem, BIOS reads them
    - set correct modes to peripheral
    - find bootable media
    - start bootloader
    - initial CPU test
    - test timers/video/keyboard
 - peripheral
    - PIT
    - CMOS
    - keyboard
    - video
    - flopy
    - HDD

-------------------------------------------------------

newtype SchedUnits = SchedUnits Int
newtype SchedId = SchedId Int
type SchedHandler = SchedId -> IO ()

data SchedCommand = SchedAdd { 
        saId :: SchedId,
        saTimeout :: SchedUnits,
        saHandler :: SchedHandler
    } |  SchedRemove SchedId

data Event = Event {
        evId :: SchedId,
        evStart :: SchedUnits,
        evExpires :: SchedUnits,
        evHandler :: SchedHandler
    }

data EventScheduler = EventScheduler {
        schEvents :: [Event],
        schCommands :: [SchedCommand]
    }

schedCommand :: EventScheduler -> SchedCommand -> EventScheduler
schedUpdate :: EventScheduler -> SchedUnits -> (Maybe SchedUnits, [SchedHandler], EventScheduler)

-------------------------------------------------------

PIC

 - IRR - input interrupts which are active
 - ISR - serviced interrupts
 - IMR - masked interrupts

 ICW1
  - LTIM (Level trigger mode)
    - 1 - Level
    - 0 - Edge
  - ADI (Call address interval)
    - 1 - 4
    - 0 - 8
  - SNGL
    - 1 - single
    - 0 - cascade
  - IC4
    - 1 - ICW4 needed
    - 0 - no ICW4 needed

 ICW2 (interrupt address)
  - bits 3-7 -> T3-T7

 ICW3 (cascade config)
  - S0-S7 - 1 has slave (master)
  - ID0-ID2 - id (slave)

 ICW4
  - SFNM (speciall fully nested mode)
    - 1 - yes
  - BUF
    - 1 - yes
  - M/S (works only in BUF mode)
    - 1 - master
    - 0 - slave
  - AEOI (automatic end of interrupt)
    - 1 - yes
  - uPM (microprocessor mode)
    - 0 - 80/85
    - 1 - 8086

 OCW1 (configure IMR)
  - 1 - mask (disable interrupt)
  - 0 - unmask (enable interrupt)

 OCW2
  - R (rotate)
    - 1 - yes
  - SL (specific)
    - 1 - yes
  - EOI (end of interrupt)
    - 1 - EOI
    - 0 - AEOI
  - L (interrupt level)
    - 3 bits

 OCW3
  - RIS
  - RR
    - 11 - Read IS
    - 01 - Read IR
  - P (poll)
    - 1 - poll command
  - SMM
  - ESMM
    - 11 - set special mask
    - 01 - reset special mask

-------------------------------------------------------

 - local timers(based on cycle counter)
   - timers which call handler when cycles counter expires
   - multiple independent cycles counters should be supported
   - each handler should have an ability to be canceled


type TimerHandler = Int -> ... -> IO ...

data CycleTimer = CycleTimer {
        ctCycles :: Int, -- timeout in cycles
        ctStart :: Int, -- when timer was started
        ctExpires :: Int, -- ctStart + ctCycles
        ctHandler :: TimerHandler
    }

data PCTimer = PCTimer {
        pcTimerList :: [CycleTimer]
    }

addTimer :: CycleTimer -> PCTimer -> PCTimer
addTimer timer pcTimer =
    ...

-------------------------------------------------------

data RWMode = RLatch | RWLeast | RWMost | RWBoth
data PITMode = PITMode0 | PITMode1 ... | PITMode5
data SelectCounter = SelectCounter0 | ... | ReadBack
data CounterMode = BinCounter | BCDCounter

data ControlWord = ControlWord {
        ctrLRWMode :: RWMode,
        ctrlPitMode :: PITMode,
        ctrlSC :: SelectCounter,
        ctrlCM :: CounterMode
    }

data PITCommand = CWCommand | LatchCommand | ReadBack

newtype PitMode = PitMode Uint8

MVar or IORef

data PitCounter = PitCounter {
        pitCW :: ControlWord,
        pitMode :: PitMode,
        pitCounter :: MVar Word64,
        pitTimeout :: Int, -- timeout in us
        pitScale :: Uint16, -- mapping between system time and counter
        pitPreset :: Uint16, -- value which is loaded into counter
        pitThreadId :: Maybe ThreadId
    }

data PIT = PIT {
        pitCounters :: [PitCounter]
    }

data PeripheralDevices = PeripheralDevices {
        peripheralPIT :: PIT,
    }

-------------------------------------------------------
