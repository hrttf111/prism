 - implement port infra
 - memory mapped infra
 - prism BIOS
    - set internal interrupts
    - main app writes indexes of storages in main mem, BIOS reads them
    - set correct modes to peripheral
    - find bootable media
    - start bootloader
    - initial CPU test
    - test timers/video/keyboard
 - peripheral
    - PIC
    - PIT
    - video
    - keyboard
    - flopy
    - HDD

-------------------------------------------------------

PIC

 - IRR - input interrupts which are active
 - ISR - serviced interrupts
 - IMR - masked interrupts

Q
 - how to send interrupt request to CPU?
    - It might take some time for CPU to start processing interrupt,
      higher priority IRQ might raise
    - What to do if interrupt goes away while CPU is doing something?
    - In case of queue it might take some time for CPU to process it,
      as the result another interrupt might occur (higher priority)
      How to notifiy CPU about it?
      Is it necessary to notify at all?
    - Real 8259 uses handshake mechansim for it
      it waits for CPU to ack interrupt to times and only after last
      ack it send interrupt number. If interrupt number was changed
      8259 will send different number after second ack
    - CPU can emulate handshake mechanism. There will be special message
      data InterruptReq
    - Virtual 8259 can send two messages: InterruptUp, InterruptDown
      First adds interrupt to IRQ queue, second removes it
      Higher prio IRQs will delete low prio IRQs
      CPU sends ACK right before processing IRQ
      Virtual 8259 will send lower prio IRQ if they were canceled
    - Virtual 8259 can send one message: InterruptUp
      It will hold MVar with number of IRQ
      This MVar is shared with 8259, which will update it once new IRQ
      arrives or old one goes down.
      CPU read MVar before processing IRQ and sends ack

data Pic8259A = Pic8259A {
        picIRR :: Uint8, -- Interrupt Request Register
        picISR :: Uint8, -- In-Service Register
        picIMR :: Uint8, -- Interrupt Mask Register
        picInitStep -- ICW step (1-4)
        picControlStep - OCW step (1-4)
    }

--data Pic = Pic {
    --}

-------------------------------------------------------

newtype PitMode = PitMode Uint8

MVar or IORef

data PitCounter = PitCounter {
        pitMode :: PitMode,
        pitCounter :: MVar Word64,
        pitTimeout :: Int, -- timeout in us
        pitScale :: Uint16, -- mapping between system time and counter
        pitPreset :: Uint16, -- value which is loaded into counter
        pitThreadId :: Maybe ThreadId
    }

data PIT = PIT {
        pitCounters :: [PitCounter]
    }

data PeripheralDevices = PeripheralDevices {
        peripheralPIT :: PIT,
    }

-------------------------------------------------------
